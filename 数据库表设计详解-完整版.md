# 🗄️ 数据库表设计详解

## 📊 数据库设计思路

### 设计原则
1. **业务导向**：根据功能模块划分表结构
2. **性能优先**：合理设计索引，避免复杂JOIN
3. **数据一致性**：外键约束 + 事务保证
4. **冗余字段**：适当冗余，减少查询次数

---

## 📋 核心表结构

### 1️⃣ 用户表（tb_user）

```sql
CREATE TABLE `tb_user` (
  `id` bigint(20) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '主键',
  `phone` varchar(11) NOT NULL COMMENT '手机号码',
  `password` varchar(128) DEFAULT '' COMMENT '密码，加密存储',
  `nick_name` varchar(32) DEFAULT '' COMMENT '昵称，默认是用户id',
  `icon` varchar(255) DEFAULT '' COMMENT '人物头像',
  `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  UNIQUE KEY `uniqe_key_phone` (`phone`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='用户表';
```

**设计说明**：
- ✅ `phone` 设置唯一索引：保证一个手机号只能注册一次
- ✅ `password` 预留字段：虽然当前用验证码登录，但为后续扩展保留
- ✅ `create_time` 和 `update_time`：自动维护时间戳

**为什么这么设计**？
- **手机号作为唯一标识**：便于验证码登录，且手机号天然唯一
- **简化字段**：只保留核心信息，其他信息存在 `tb_user_info`（读写分离）

---

### 2️⃣ 用户信息表（tb_user_info）

```sql
CREATE TABLE `tb_user_info` (
  `user_id` bigint(20) UNSIGNED NOT NULL COMMENT '主键，用户id',
  `city` varchar(64) DEFAULT '' COMMENT '城市名称',
  `introduce` varchar(128) DEFAULT NULL COMMENT '个人介绍',
  `fans` int(8) UNSIGNED DEFAULT 0 COMMENT '粉丝数量',
  `followee` int(8) UNSIGNED DEFAULT 0 COMMENT '关注的人的数量',
  `gender` tinyint(1) UNSIGNED DEFAULT 0 COMMENT '性别，0：男，1：女',
  `birthday` date DEFAULT NULL COMMENT '生日',
  `credits` int(8) UNSIGNED DEFAULT 0 COMMENT '积分',
  `level` tinyint(1) UNSIGNED DEFAULT 0 COMMENT '会员级别，0~9级',
  `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`user_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='用户详情表';
```

**设计说明**：
- ✅ **一对一关系**：`user_id` 即主键又是外键
- ✅ **读写分离**：核心信息在 `tb_user`，扩展信息在 `tb_user_info`
- ✅ **冗余字段**：`fans`、`followee` 冗余，避免COUNT查询

**为什么分成两张表**？
- **查询性能**：登录只需查 `tb_user`（小表），不关心详情
- **存储优化**：`tb_user_info` 可选，不是每个用户都填写

---

### 3️⃣ 商铺表（tb_shop）

```sql
CREATE TABLE `tb_shop` (
  `id` bigint(20) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '主键',
  `name` varchar(128) NOT NULL COMMENT '商铺名称',
  `type_id` bigint(20) UNSIGNED NOT NULL COMMENT '商铺类型的id',
  `images` varchar(1024) NOT NULL COMMENT '商铺图片，多张以,隔开',
  `area` varchar(128) DEFAULT NULL COMMENT '商圈，例如陆家嘴',
  `address` varchar(255) NOT NULL COMMENT '地址',
  `x` double UNSIGNED NOT NULL COMMENT '经度',
  `y` double UNSIGNED NOT NULL COMMENT '维度',
  `avg_price` bigint(10) UNSIGNED DEFAULT NULL COMMENT '均价',
  `sold` int(10) UNSIGNED ZEROFILL NOT NULL COMMENT '销量',
  `comments` int(10) UNSIGNED ZEROFILL NOT NULL COMMENT '评论数量',
  `score` int(2) UNSIGNED ZEROFILL NOT NULL COMMENT '评分，1~5分，乘10保存',
  `open_hours` varchar(32) DEFAULT NULL COMMENT '营业时间',
  `create_time` timestamp NULL DEFAULT CURRENT_TIMESTAMP,
  `update_time` timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  KEY `foreign_key_type` (`type_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='商铺表';
```

**设计说明**：
- ✅ `x`, `y` 存储经纬度：支持地理位置查询（配合Redis GEO）
- ✅ `type_id` 索引：按类型查询商铺的场景多
- ✅ `score` 乘10存储：避免浮点数精度问题（4.5分存45）

**为什么这么设计**？
- **地理位置查询**：配合Redis GEO实现"附近商铺"功能
- **冗余字段**：`sold`、`comments` 冗余，避免JOIN查询

---

### 4️⃣ 优惠券表（tb_voucher）

```sql
CREATE TABLE `tb_voucher` (
  `id` bigint(20) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '主键',
  `shop_id` bigint(20) UNSIGNED DEFAULT NULL COMMENT '商铺id',
  `title` varchar(255) NOT NULL COMMENT '代金券标题',
  `sub_title` varchar(255) DEFAULT NULL COMMENT '副标题',
  `rules` varchar(1024) DEFAULT NULL COMMENT '使用规则',
  `pay_value` bigint(10) UNSIGNED NOT NULL COMMENT '支付金额（分）',
  `actual_value` bigint(10) NOT NULL COMMENT '抵扣金额（分）',
  `type` tinyint(1) UNSIGNED NOT NULL DEFAULT 0 COMMENT '0普通券；1秒杀券',
  `status` tinyint(1) UNSIGNED NOT NULL DEFAULT 1 COMMENT '1上架；2下架；3过期',
  `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='优惠券表';
```

**设计说明**：
- ✅ `type` 区分普通券和秒杀券
- ✅ **金额单位：分**：避免浮点数精度问题（10.50元存1050分）

---

### 5️⃣ 秒杀优惠券表（tb_seckill_voucher）

```sql
CREATE TABLE `tb_seckill_voucher` (
  `voucher_id` bigint(20) UNSIGNED NOT NULL COMMENT '关联的优惠券的id',
  `stock` int(8) NOT NULL COMMENT '库存',
  `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `begin_time` timestamp NOT NULL DEFAULT '0000-00-00 00:00:00' COMMENT '生效时间',
  `end_time` timestamp NOT NULL DEFAULT '0000-00-00 00:00:00' COMMENT '失效时间',
  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`voucher_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='秒杀优惠券表';
```

**设计说明**：
- ✅ **一对一关系**：`voucher_id` 是主键，同时关联 `tb_voucher`
- ✅ `stock` 字段：核心字段，配合乐观锁防止超卖

**为什么单独一张表**？
- **分离关注点**：普通券无需库存，秒杀券才需要
- **性能优化**：秒杀场景频繁更新 `stock`，独立表减少锁竞争

---

### 6️⃣ 优惠券订单表（tb_voucher_order）

```sql
CREATE TABLE `tb_voucher_order` (
  `id` bigint(20) NOT NULL COMMENT '主键',
  `user_id` bigint(20) UNSIGNED NOT NULL COMMENT '下单的用户id',
  `voucher_id` bigint(20) UNSIGNED NOT NULL COMMENT '购买的代金券id',
  `pay_type` tinyint(1) UNSIGNED NOT NULL DEFAULT 1 COMMENT '支付方式',
  `status` tinyint(1) UNSIGNED NOT NULL DEFAULT 1 COMMENT '订单状态',
  `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `pay_time` timestamp NULL DEFAULT NULL COMMENT '支付时间',
  `use_time` timestamp NULL DEFAULT NULL COMMENT '核销时间',
  `refund_time` timestamp NULL DEFAULT NULL COMMENT '退款时间',
  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='优惠券订单表';
```

**设计说明**：
- ✅ `id` 使用全局ID生成器（RedisIdWorker）
- ✅ 多个时间字段：记录订单全生命周期

**为什么ID用自定义生成器**？
- **分布式环境**：自增ID在分库分表时会冲突
- **安全性**：自增ID可被推测（订单量、用户量）
- **唯一性**：时间戳 + 序列号保证全局唯一

---

### 7️⃣ 探店笔记表（tb_blog）

```sql
CREATE TABLE `tb_blog` (
  `id` bigint(20) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '主键',
  `shop_id` bigint(20) NOT NULL COMMENT '商户id',
  `user_id` bigint(20) UNSIGNED NOT NULL COMMENT '用户id',
  `title` varchar(255) NOT NULL COMMENT '标题',
  `images` varchar(2048) NOT NULL COMMENT '探店的照片，多张以,隔开',
  `content` varchar(2048) NOT NULL COMMENT '探店的文字描述',
  `liked` int(8) UNSIGNED DEFAULT 0 COMMENT '点赞数量',
  `comments` int(8) UNSIGNED DEFAULT NULL COMMENT '评论数量',
  `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='探店笔记表';
```

**设计说明**：
- ✅ `liked` 冗余字段：避免COUNT查询Redis
- ✅ `images` 存多张图片：逗号分隔（NoSQL思想）

**点赞数据存储在哪**？
- **MySQL**：`liked` 字段（定期从Redis同步）
- **Redis ZSet**：`blog:liked:{blogId}`（实时数据）

---

### 8️⃣ 关注表（tb_follow）

```sql
CREATE TABLE `tb_follow` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `user_id` bigint(20) UNSIGNED NOT NULL COMMENT '用户id',
  `follow_user_id` bigint(20) UNSIGNED NOT NULL COMMENT '关联的用户id',
  `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='关注表';
```

**设计说明**：
- ✅ **自关联表**：用户关注用户
- ✅ 无唯一索引：允许多次关注（历史记录）

**常见问题**：
- **如何查询共同关注**？
  ```java
  // 使用Redis Set交集
  Set<String> common = stringRedisTemplate.opsForSet()
      .intersect("follow:" + userId1, "follow:" + userId2);
  ```

---

## 🎯 设计亮点

### 1. 读写分离表
```
tb_user（核心字段）
    ├─ 登录查询（高频）
    └─ 字段少，查询快

tb_user_info（扩展字段）
    ├─ 个人主页查询（低频）
    └─ 字段多，独立表
```

### 2. 一对一关系
```
tb_voucher（优惠券基础信息）
    └─ tb_seckill_voucher（秒杀券扩展信息）
        ├─ 不是每个券都是秒杀券
        └─ 秒杀券频繁更新stock，独立表减少锁竞争
```

### 3. 冗余字段设计
```sql
-- ❌ 不好的设计：每次查询都要COUNT
SELECT COUNT(*) FROM tb_follow WHERE follow_user_id = ?

-- ✅ 好的设计：冗余字段
tb_user_info.fans = 粉丝数（定期同步）
```

### 4. 金额单位：分
```java
// 避免浮点数精度问题
BigDecimal price = new BigDecimal("10.50");  // ❌ 可能有精度误差
Long price = 1050L;  // ✅ 以分为单位，整数存储
```

---

## 📊 索引设计

### 原则
1. **查询条件必加索引**：WHERE、ORDER BY、JOIN的字段
2. **覆盖索引优先**：查询字段都在索引中，避免回表
3. **索引不是越多越好**：影响INSERT/UPDATE性能

### 示例
```sql
-- tb_shop 表
KEY `foreign_key_type` (`type_id`)  -- 按类型查询商铺

-- tb_blog 表
KEY `idx_user_id` (`user_id`)  -- 查询用户的笔记
KEY `idx_create_time` (`create_time`)  -- 按时间排序

-- tb_voucher_order 表
KEY `idx_user_voucher` (`user_id`, `voucher_id`)  -- 联合索引，查询用户是否已购买
```

---

## 🎤 面试问答

### Q1: 为什么用户表要分两张？

**答**：读写分离 + 性能优化
- `tb_user`：核心字段，登录高频查询，小表查询快
- `tb_user_info`：扩展字段，个人主页低频查询，减少`tb_user`表大小

---

### Q2: 为什么秒杀券要单独一张表？

**答**：
1. **不是每个券都是秒杀券**，普通券无需库存字段
2. **秒杀场景频繁更新stock**，独立表减少锁竞争
3. **一对一关系**，`voucher_id`既是主键也是外键

---

### Q3: 订单ID为什么不用自增？

**答**：分布式环境下的问题
- ❌ 自增ID在分库分表时会冲突
- ❌ 可被推测（订单量、用户量等敏感信息）
- ✅ 使用Redis生成全局唯一ID（时间戳 + 序列号）

---

### Q4: 如何保证库存不超卖？

**答**：多层防护
1. **Lua脚本**：原子性扣减Redis库存
2. **数据库乐观锁**：
   ```sql
   UPDATE tb_seckill_voucher 
   SET stock = stock - 1 
   WHERE voucher_id = ? AND stock > 0
   ```
3. **分布式锁**：防止同一用户并发下单

---

### Q5: 粉丝数如何统计？

**答**：冗余字段 + 定时同步
```java
// 实时（Redis）
SCARD follow:{userId}  // 粉丝数

// 定期同步到MySQL
UPDATE tb_user_info SET fans = ? WHERE user_id = ?
```

---

## 📝 总结

### 设计原则
✅ **业务导向**：根据功能划分表  
✅ **性能优先**：冗余字段 > 复杂JOIN  
✅ **分离关注点**：读写分离、冷热分离  
✅ **合理索引**：查询字段必加索引  

### 关键设计
| 设计 | 目的 | 示例 |
|-----|------|------|
| 读写分离表 | 提升查询性能 | user / user_info |
| 一对一关系 | 灵活扩展 | voucher / seckill_voucher |
| 冗余字段 | 避免JOIN | fans, liked |
| 金额单位：分 | 避免精度问题 | 10.50元 = 1050分 |
| 全局ID生成器 | 分布式唯一 | RedisIdWorker |

---

**祝你面试成功！🚀**

