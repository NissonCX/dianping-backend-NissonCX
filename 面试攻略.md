# 🎯 黑马点评（虎溪锐评）项目面试攻略

> **⚠️ 重要提示**：
> 你的简历上写了 **RabbitMQ** 和 **JWT**，但项目实际代码使用的是 **Redis Stream** 和 **Session/Redis Token**。
> 面试时如果被问到，建议按**实际代码**回答，或者解释为：“简历上写的是我熟悉的另一个版本/方案，但本项目为了轻量化和深入理解Redis，采用了Redis Stream实现消息队列，用Redis+Token实现分布式Session。”
> **本攻略基于项目实际代码编写。**

---

## 📚 目录
1. [项目介绍模板](#1-项目介绍模板)
2. [核心业务详解（代码级）](#2-核心业务详解)
    - [2.1 秒杀优惠券（异步下单）](#21-秒杀优惠券异步下单)
    - [2.2 商户查询缓存优化](#22-商户查询缓存优化)
    - [2.3 达人探店（Feed流）](#23-达人探店feed流)
    - [2.4 附近商户（GEO）](#24-附近商户geo)
    - [2.5 用户签到（Bitmap）](#25-用户签到bitmap)
3. [高频面试题 Q&A](#3-高频面试题-qa)
4. [项目亮点与难点总结](#4-项目亮点与难点总结)

---

## 1. 项目介绍模板

**面试官：请介绍一下你的这个项目。**

**参考回答：**
> “这是一个基于 Spring Boot 的本地生活服务平台，类似大众点评。我主要负责后端核心业务的开发。
>
> 项目涵盖了**用户登录、商户查询、优惠券秒杀、达人探店、关注推送**等功能。
>
> **技术亮点方面**，我重点使用了 **Redis** 来解决高并发下的性能问题：
> 1.  **秒杀抢购**：这是最大的挑战。我从最初的数据库直连，优化到**异步下单**方案。利用 **Redis Stream** 做消息队列，配合 **Lua 脚本**保证库存扣减的原子性，将 QPS 从几百提升到了上万，响应时间降至毫秒级。同时使用 **Redisson** 分布式锁解决了超卖和一人一单问题。
> 2.  **缓存优化**：针对商户查询，我设计了多级缓存策略，解决了**缓存穿透、击穿和雪崩**问题。特别是针对热点 Key 击穿，我实现了**互斥锁**和**逻辑过期**两种方案。
> 3.  **社交功能**：利用 Redis 的 **ZSet** 实现了 Feed 流的推模式和滚动分页，解决了传统分页在动态数据下的重复/遗漏问题。
> 4.  **其他场景**：使用 **GEO** 实现了附近商户搜索，使用 **Bitmap** 实现了高效的用户签到统计。”

---

## 2. 核心业务详解

### 2.1 秒杀优惠券（异步下单）

**核心逻辑**：将同步的“校验+扣减+下单”拆分为“**Redis快速校验**”和“**异步数据库下单**”。

#### 🚀 流程步骤（必须背熟）
1.  **用户请求**：用户发起秒杀请求。
2.  **Redis 校验 (Lua脚本)**：
    *   判断库存是否充足 (`get seckill:stock:{id}`)。
    *   判断是否重复下单 (`sismember seckill:order:{id} {userId}`)。
    *   **如果校验通过**：
        *   扣减 Redis 库存 (`decr seckill:stock:{id}`)。
        *   记录用户已下单 (`sadd seckill:order:{id} {userId}`)。
        *   发送订单消息到 **Redis Stream** (`xadd stream.orders ...`)。
    *   **如果校验失败**：直接返回错误信息。
3.  **返回结果**：Lua 执行成功，立即返回订单 ID（此时数据库还没写，但用户认为已成功）。
4.  **异步下单 (后台线程)**：
    *   线程池中的线程循环读取 Stream 消息 (`XREADGROUP`)。
    *   解析消息，获取 userId, voucherId, orderId。
    *   获取 **Redisson 分布式锁**（兜底，防止并发安全问题）。
    *   **数据库操作**：
        *   再次校验一人一单（查询数据库）。
        *   扣减数据库库存（乐观锁 `stock > 0`）。
        *   创建订单。
    *   **ACK 确认**：处理成功后，发送 `XACK` 确认消息。

#### 🔑 关键代码点
*   **Lua 脚本**：`seckill.lua`，保证了 Redis 中判断库存、校验资格、扣减库存、发送消息这几步的**原子性**。
*   **Redis Stream**：
    *   `XADD`：生产者发送消息。
    *   `XREADGROUP`：消费者组读取消息，支持**消息确认（ACK）**和**持久化**，比 List 和 Pub/Sub 更可靠。
    *   **Pending List**：如果消费者崩溃未 ACK，消息会留在 Pending List，重启后通过 `handlePendingList` 方法处理，保证**消息不丢失**。
*   **Redisson 锁**：
    *   `redissonClient.getLock("lock:order:" + userId)`。
    *   虽然 Lua 挡住了大部分并发，但为了数据库数据的绝对安全（防止 Redis 挂了数据不一致等极端情况），在异步写入数据库时依然加了锁。

---

### 2.2 商户查询缓存优化

**场景**：查询商户详情 `queryById`。

#### 🛡️ 缓存穿透
*   **问题**：查询一个不存在的 ID，Redis 没数据，请求直达数据库，数据库也没数据，导致每次都查库。
*   **解决**：**缓存空对象**。如果数据库查不到，在 Redis 存一个空值（如 `""`），并设置较短的 TTL（如 2 分钟）。

#### 🛡️ 缓存击穿
*   **问题**：热点 Key 过期，大量并发请求瞬间击穿 Redis 打到数据库。
*   **解决 1：互斥锁 (Mutex)**
    *   原理：缓存失效时，不是所有线程都去查库。大家先抢锁（`setnx`），抢到的去查库写缓存，没抢到的休眠重试。
    *   优点：数据一致性强。缺点：性能略差。
*   **解决 2：逻辑过期 (Logical Expiration)**
    *   原理：Redis Key 设置为永不过期，但在 Value 中存一个 `expireTime`。查询时发现逻辑时间过期了，获取互斥锁，**开启新线程**去异步重建缓存，旧线程直接返回旧数据。
    *   优点：性能极高。缺点：会有短暂的数据不一致。

#### 🛡️ 缓存雪崩
*   **问题**：大量 Key 同时过期，或 Redis 宕机。
*   **解决**：TTL 添加随机值；搭建 Redis 集群（哨兵/Cluster）。

---

### 2.3 达人探店（Feed流）

**场景**：关注的人发了笔记，我要在“关注”列表看到。

#### 📡 推模式 (Push)
*   **实现**：
    *   博主发笔记时，查询他的所有粉丝。
    *   遍历粉丝，将笔记 ID 推送到粉丝的收件箱（Redis **ZSet**）。
    *   Key: `feed:{userId}`，Value: `blogId`，Score: `timestamp`（按时间排序）。
*   **为什么用 ZSet？**：因为需要按时间排序，且支持分页。

#### 📜 滚动分页
*   **问题**：传统分页（Page, Size）在动态列表中，如果有新数据插入，会导致数据重复出现。
*   **解决**：使用 `ZREVRANGEBYSCORE` 命令。
    *   参数：`max` (上一次查询的最小时间戳), `min` (0), `offset` (偏移量), `count` (每页条数)。
    *   每次查询记录最后一条的时间戳，作为下一次查询的 `max`。

---

### 2.4 附近商户 (GEO)

**场景**：搜索附近的店铺，按距离排序。

*   **实现**：
    *   使用 Redis 的 **GEO** 数据结构（底层是 ZSet）。
    *   `GEOADD`：添加商户经纬度。
    *   `GEOSEARCH`：搜索指定坐标半径内的点，并按距离排序。
*   **优势**：比数据库计算距离快得多，且支持排序。

---

### 2.5 用户签到 (Bitmap)

**场景**：记录用户每天是否签到，统计连续签到天数。

*   **实现**：
    *   使用 Redis **Bitmap**（位图）。
    *   Key: `sign:{userId}:{yyyyMM}`。
    *   `SETBIT key offset 1`：签到（offset 是当月第几天）。
    *   `BITFIELD`：获取一段二进制数据，用于统计连续签到。
*   **优势**：极其节省内存。一个月的数据只需要 4 字节（32位）。

---

## 3. 高频面试题 Q&A

**Q1: 你的秒杀方案如何保证不超卖？**
> **A:** 我采用了三层防护：
> 1.  **Redis 层**：Lua 脚本原子性判断库存和扣减，这是第一道防线，挡住绝大部分流量。
> 2.  **数据库层**：使用乐观锁，更新库存时加上 `where stock > 0` 的条件，利用数据库行锁保证不会扣成负数。
> 3.  **分布式锁**：Redisson 锁保证同一用户在同一时间只能发起一个请求，防止一人多单。

**Q2: 为什么使用 Redis Stream 而不是 List 或 Pub/Sub？**
> **A:**
> *   **List**：无法实现消费者组，消息消费后就没了，不支持多播（虽然秒杀不需要多播），且没有内置的 ACK 机制。
> *   **Pub/Sub**：消息不持久化，如果消费者下线，消息就丢失了。
> *   **Stream**：支持持久化、支持消费者组（负载均衡）、支持 ACK 确认机制、支持 Pending List（找回未确认消息），非常适合做可靠的消息队列。

**Q3: 数据库和缓存的一致性怎么保证？**
> **A:** 我采用的是 **Cache Aside Pattern（旁路缓存模式）**。
> *   **读**：先读缓存，命中返回；未命中查库，写入缓存。
> *   **写**：**先更新数据库，再删除缓存**。
> *   **为什么先更库后删缓存？**：相比先删缓存后更库，发生并发不一致的概率更小。为了兜底，我还可以给缓存设置一个过期时间，或者使用延时双删策略。

**Q4: 分布式锁 Redisson 的看门狗机制是什么？**
> **A:** 如果业务执行时间超过了锁的过期时间，锁会被自动释放，导致并发问题。Redisson 提供了一个“看门狗”机制，在锁没有被显式释放且业务还在运行（持有锁的线程还在）时，它会每隔一段时间（默认 10s）自动延长锁的有效期，直到业务完成释放锁。

**Q5: 你的 ID 生成器是怎么实现的？**
> **A:** 我实现了一个基于 Redis 的全局唯一 ID 生成器。
> 结构是：**1位符号位 + 31位时间戳 + 32位序列号**。
> *   时间戳保证了 ID 的有序性。
> *   序列号利用 Redis 的 `INCR` 原子递增，保证唯一性。
> *   Key 中包含日期（如 `icr:order:20231219`），方便按天统计，也避免单个 Key 数值过大。

---

## 4. 项目亮点与难点总结

**亮点（写在简历/自我介绍中）：**
1.  **高性能秒杀**：通过 Redis + Lua + Stream 异步下单，将 QPS 提升了数十倍，解决了传统数据库秒杀的性能瓶颈。
2.  **多级缓存设计**：灵活运用互斥锁和逻辑过期解决缓存击穿问题，保障系统稳定性。
3.  **海量数据处理**：利用 Bitmap 存储签到数据，利用 GEO 处理地理位置，体现了对 Redis 高级数据结构的熟练运用。
4.  **复杂场景解决**：Feed 流的推模式与滚动分页设计，解决了动态列表的分页难题。

**难点（面试被问到“遇到的困难”）：**
1.  **消息丢失问题**：在使用 Stream 时，如何处理消费者宕机导致的消息未处理？
    *   *解决*：利用 Pending List 机制，在应用重启或异常捕获时，专门读取 Pending List 中的消息进行二次处理和 ACK。
2.  **一人一单的并发安全**：在集群模式下，`synchronized` 锁失效。
    *   *解决*：引入 Redisson 分布式锁，锁对象为 `userId`，确保集群环境下同一用户操作的串行化。
3.  **缓存击穿的选型**：在互斥锁和逻辑过期之间做选择。
    *   *解决*：对于秒杀这种对一致性要求不那么苛刻（允许短暂延迟）但对可用性要求极高的场景，我选择了逻辑过期方案。

---
**祝你面试顺利！**

